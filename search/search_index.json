{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Paperbush \ud83c\udf3f","text":"<p>Paperbush is a super concise argument parsing tool that simplifies the process of creating command-line argument parsers in Python. With Paperbush, you can define your parser in just a single line of code using a custom built-in language, which is then translated directly into the built-in <code>argparse</code> module equivalent. This means that in most cases, moving to Paperbush is just a matter of changing the parser definition, as <code>Paperbush.parse_args()</code> returns an <code>argparse.Namespace</code> object.</p>"},{"location":"#installation","title":"Installation","text":"<p>Paperbush is available on PyPI and can be installed with <code>pip</code>, or any other Python package manager: <pre><code>$ pip install paperbush\n</code></pre> (Some systems may require you to use <code>pip3</code>, <code>python -m pip</code>, or <code>py -m pip</code>)</p>"},{"location":"#examples","title":"Examples","text":""},{"location":"#features","title":"Features","text":"<ul> <li>short name inferrence</li> <li>mutually exclusive groups</li> <li>choices and the count action</li> <li>default values</li> <li>required arguments</li> <li>type conversion</li> <li>help messages</li> </ul>"},{"location":"#known-limitations","title":"Known Limitations","text":"<p>Currently Paperbush has no support for:</p> <ul> <li>aliases</li> <li>subparsers</li> </ul>"},{"location":"#license","title":"License","text":"<p>Paperbush is licensed under the MIT License.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#paperbush","title":"Paperbush","text":"<p><pre><code>Paperbush(pattern: str, *values: Any, infer_names: bool = True)\n</code></pre> Creates a Paperbush parser; takes a string pattern written in the Paperbush custom language, an arbitrary number of reference values, and the <code>infer_names</code> flag which specifies whether arguments with only long names should have the short names inferred (<code>True</code> by default).</p> <p>Warning</p> <p>Keeping <code>infer_names</code> true is going to cause name collisions between arguments which start with the same letter (for example <code>Paperbush(\"--fix --force\")</code>).</p>"},{"location":"api/#paperbushfrom_iterable","title":"Paperbush.from_iterable","text":"<p><pre><code>Paperbush.from_iterable(\niterable: Iterable[str],\n*values: Any,\ninfer_names: bool = True\n)\n</code></pre> Creates a Paperbush parser from an iterable of patterns.</p> <p>Example</p> <pre><code>a = Paperbush.from_iterable([\"x:int\", \"y:(3, 4, 5)=4\"])\nb = Paperbush(\"x:int y:(3, 4, 5)=4\")\nassert a == b\n</code></pre>"},{"location":"api/#paperbushfrom_mapping","title":"Paperbush.from_mapping","text":"<p><pre><code>Paperbush.from_mapping(\nmapping: Mapping[str, str],\n*values: Any,\ninfer_names: bool = True\n)\n</code></pre> Creates a Paperbush parser from a mapping, where keys are patterns and values are help messages.</p> argparsePaperbush <pre><code>from argparse import ArgumentParser\nparser = ArgumentParser()\nparser.add_argument(\"x\", type=int, help=\"the base\")\nparser.add_argument(\"y\", type=int, help=\"the exponent\")\n</code></pre> <pre><code>from paperbush import Paperbush\nparser = Paperbush.from_mapping({\n\"x:int\": \"the base\",\n\"y:int\": \"the exponent\"\n})\n</code></pre>"},{"location":"api/#paperbushparse","title":"Paperbush.parse","text":"<pre><code>Paperbush.parse(self, args: str | list[str]) -&gt; argparse.Namespace\n</code></pre> <p>Parses command line arguments using the predefined pattern and returns an <code>argparse.Namespace</code> object. Accepts either a list of strings or a single string (which is split with <code>shlex.split</code>).</p>"},{"location":"api/#paperbushparse_args","title":"Paperbush.parse_args","text":"<p><pre><code>Paperbush.parse_args(self) -&gt; argparse.Namespace\n</code></pre> Equivalent to <code>Paperbush.parse(sys.argv)</code>.</p>"},{"location":"dsl/","title":"Language Reference","text":"<p>This page describes how to use the Paperbush custom language. Considering the library is built on top of <code>argparse</code>, this page will contain many comparions to that library.</p>"},{"location":"dsl/#positional-arguments","title":"Positional arguments","text":"<p>Positional arguments are defined simply by specifying their names with no leading hyphens.</p> argparsePaperbush <pre><code>from argparse import ArgumentParser\nparser = ArgumentParser()\nparser.add_argument(\"echo\")\n</code></pre> <pre><code>from paperbush import Paperbush\nparser = Paperbush(\"echo\")\n</code></pre>"},{"location":"dsl/#optional-arguments","title":"Optional arguments","text":"<p>Optional arguments are defined with leading hyphens:</p> <ul> <li><code>-n</code> for the short name</li> <li><code>--name</code> for the long name</li> </ul> <p>If you wish to provide both names, they have to be separated with a <code>|</code>.</p> <p>However, Paperbush does short name inference by default, which means that you only need to specify the long name when the short name would be the first letter of the long name.</p> <p>Also, bare optional arguments (without type specification or default values for example) have their action set to <code>store_true</code>. This is the only case1 where this behavior occurs.</p> argparsePaperbushPaperbush (short name inference) <pre><code>from argparse import ArgumentParser\nparser = ArgumentParser()\nparser.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\n</code></pre> <pre><code>from paperbush import Paperbush\nparser = Paperbush(\"-v|--verbose\")\n</code></pre> <pre><code>from paperbush import Paperbush\nparser = Paperbush(\"--verbose\")\n</code></pre> <p>If you don't want Paperbush to infer those names, define the parser with the <code>infer_names</code> parameter disabled.</p> argparsePaperbush <pre><code>from argparse import ArgumentParser\nparser = ArgumentParser()\nparser.add_argument(\"--verbose\", action=\"store_true\")\n</code></pre> <pre><code>from paperbush import Paperbush\nparser = Paperbush(\"--verbose\", infer_names=False)\n</code></pre>"},{"location":"dsl/#argument-type","title":"Argument type","text":"<p>Arguments can have their type specified by appending a colon followed by the type name to the argument (<code>name:type</code>). The type name has to be a valid variable name.</p> argparsePaperbush <pre><code>from argparse import ArgumentParser\nparser = ArgumentParser()\nparser.add_argument(\"square\", type=int)\nparser.add_argument(\"--verbosity\", type=int)\n</code></pre> <pre><code>from paperbush import Paperbush\nparser = Paperbush(\"square:int --verbosity:int\")\n</code></pre> <p>By setting the default type (<code>str</code>) you can get the original behavior of optional arguments in <code>argparse</code>:</p> argparsePaperbush <pre><code>from argparse import ArgumentParser\nparser = ArgumentParser()\nparser.add_argument(\"--verbosity\")\n</code></pre> <pre><code>from paperbush import Paperbush\nparser = Paperbush(\"--verbosity:str\")\n</code></pre> <p>Note</p> <p>Currently only built-in types are supported.</p>"},{"location":"dsl/#required-arguments","title":"Required arguments","text":"<p>Arguments can be made mandatory by putting a <code>!</code> after their name.</p> argparsePaperbush <pre><code>from argparse import ArgumentParser\nparser = ArgumentParser()\nparser.add_argument(\"-o\", \"--output\", action=\"store_true\", required=True)\n</code></pre> <pre><code>from paperbush import Paperbush\nparser = Paperbush(\"--output!\")\n</code></pre>"},{"location":"dsl/#number-of-arguments","title":"Number of arguments","text":"<p>The number of arguments (nargs) is specified the same way as the argument type, by following our argument with a colon and then either an integer, <code>?</code>, <code>*</code>, or <code>+</code>:</p> argparsePaperbush <pre><code>from argparse import ArgumentParser\nparser = ArgumentParser()\nparser.add_argument(\"-f\", \"--foo\", nargs=3)\nparser.add_argument(\"-b\", \"--bar\", nargs=\"*\")\n</code></pre> <pre><code>from paperbush import Paperbush\nparser = Paperbush(\"--foo:3 --bar:*\")\n</code></pre>"},{"location":"dsl/#choices","title":"Choices","text":"<p>You can restrict what values an argument can accept by specifying <code>choices</code>. They're added the same way as <code>type</code> or <code>nargs</code>, by adding a container after a colon:</p> argparsePaperbush <pre><code>from argparse import ArgumentParser\nparser = ArgumentParser()\nparser.add_argument(\"-v\", \"--verbosity\", type=int, choices=[0, 1, 2])\n</code></pre> <pre><code>from paperbush import Paperbush\nparser = Paperbush(\"--verbosity:int:[0, 1, 2]\")\n</code></pre> <p>Note</p> <p>The order doesn't matter, <code>--verbosity:[0, 1, 2]:int</code> is as valid as <code>--verbosity:int:[0, 1, 2]</code>.</p>"},{"location":"dsl/#counting","title":"Counting","text":"<p>Arguments can have the \"count\" action set by following the argument name with <code>++</code>. Paperbush also sets the default to <code>0</code> for convenience:</p> argparsePaperbush <pre><code>from argparse import ArgumentParser\nparser = ArgumentParser()\nparser.add_argument(\"-v\", \"--verbose\", action=\"count\", default=0)\n</code></pre> <pre><code>from paperbush import Paperbush\nparser = Paperbush(\"--verbose++\")\n</code></pre> <p>Note</p> <p>Just like with the \"colon options\", there's no difference between <code>--verbose!++</code> and <code>--verbose++!</code>.</p>"},{"location":"dsl/#default-values","title":"Default values","text":"<p>Default argument values are set at their very end, preceded by the <code>=</code> sign:</p> argparsePaperbush <pre><code>from argparse import ArgumentParser\nparser = ArgumentParser()\nparser.add_argument(\"-b\", \"--base\", type=float, required=True)\nparser.add_argument(\"-e\", \"--exponent\", type=float, default=2.0)\n</code></pre> <pre><code>from paperbush import Paperbush\nparser = Paperbush(\"--base!:float --exponent:float=2.0\")\n</code></pre>"},{"location":"dsl/#value-references","title":"Value references","text":"<p>Defining a parser using a single string has one major issue: working with variables. Since it's all a string, passing the variable name would need Paperbush to manually evaluate it when parsing, which would require the user to pass <code>globals()</code>, which doesn't look the best. Also evaluating the variable on the spot (e.g. using an f-string) doesn't work for most types and it quite often comes with copying data.</p> <p>Therefore Paperbush uses value references, which let you refer to variables without using them directly in the string, which is both a speed and memory improvement (even though they're not necessarily relevant for an argument parser).</p> <p>Value references are marked with <code>$n</code>. All of these parser definitions are equivalent:</p> argparsePaperbushPaperbush (with value references) <pre><code>from argparse import ArgumentParser\noptions = list(range(10_000))\nparser = ArgumentParser()\nparser.add_argument(\"-o\", \"--option\", choices=options)\n</code></pre> <pre><code>from paperbush import Paperbush\noptions = list(range(10_000))\nparser = Paperbush(f\"--option:{options}\")\n# we're lucky that str(options) is valid syntax\n# this takes ~25 seconds\n</code></pre> <pre><code>from paperbush import Paperbush\noptions = list(range(10_000))\nparser = Paperbush(\"--option:$0\", options)\n# this takes 0.002s\n# (~14K times faster for a very extreme case)\n</code></pre> <p>(the above runtimes were measured on a MacBook Air M1)</p> <p>Another example of using value references:</p> PaperbushPaperbush (with value references) <pre><code>from paperbush import Paperbush\nparser = Paperbush(\"--verbose:int:1:(0, 1, 2, 3)=0\")\n</code></pre> <pre><code>from paperbush import Paperbush\nparser = Paperbush(\"--verbose:int:1:$0=$1\", (0, 1, 2, 3), 0)\n</code></pre> <p>Note</p> <p>Because of implementation details, value references currently can only be used for choices and default values.</p>"},{"location":"dsl/#mutually-exclusive-groups","title":"Mutually exclusive groups","text":"<p>Mutually exclusive groups are made by XORing 2 or more arguments:</p> argparsePaperbush <pre><code>from argparse import ArgumentParser\nparser = ArgumentParser()\nparser.add_argument(\"x\", type=int)\ngroup = parser.add_mutually_exclusive_group()\ngroup.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\ngroup.add_argument(\"-s\", \"--silent\", action=\"store_true\")\n</code></pre> <pre><code>from paperbush import Paperbush\nparser = Paperbush(\"x:int --verbose ^ --silent\")\n</code></pre> <p>To indicate that at least one of the mutually exclusive arguments is required, at least one of them must be marked as required itself:</p> argparsePaperbush <pre><code>from argparse import ArgumentParser\nparser = ArgumentParser()\nparser.add_argument(\"-n\", \"--name\")\ngroup = parser.add_mutually_exclusive_group(required=True)\ngroup.add_argument(\"-f\", \"--foo\", action=\"store_true\")\ngroup.add_argument(\"-b\", \"--bar\", action=\"store_true\")\ngroup.add_argument(\"-z\", \"--baz\", action=\"store_true\")\nparser.add_argument(\"-o\", \"--output\")\n</code></pre> <pre><code>from paperbush import Paperbush\nparser = Paperbush(\"--name:str --foo! ^ --bar ^ -z|--baz --output:str\")\n</code></pre> <ol> <li> <p>Except for required arguments, for compatibility with mutually exclusive groups.\u00a0\u21a9</p> </li> </ol>"},{"location":"examples/","title":"Examples","text":"<p>The following page shows a few examples comparing Paperbush to <code>argparse</code>.</p> argparsePaperbush <pre><code>from argparse import ArgumentParser\nparser = ArgumentParser()\nparser.add_argument(\"-b\", \"--base\", type=float, required=True)\nparser.add_argument(\"-e\", \"--exponent\", type=float, default=2.0)\n</code></pre> <pre><code>from paperbush import Paperbush\nparser = Paperbush(\"--base!:float --exponent:float=2.0\")\n</code></pre> argparsePaperbush <pre><code>from argparse import ArgumentParser\nparser = ArgumentParser()\ngroup = parser.add_mutually_exclusive_group()\nparser.add_argument(\"x\", type=int)\nparser.add_argument(\"y\", type=int)\ngroup.add_argument(\"-v\", \"--verbose\", action=\"count\", default=0)\ngroup.add_argument(\"-q\", \"--quiet\", action=\"store_true\")\n</code></pre> <pre><code>from paperbush import Paperbush\nparser = Paperbush(\"x:int y:int --verbose++ ^ --quiet\")\n</code></pre> argparsePaperbush <pre><code>from argparse import ArgumentParser\nUNSET = object()\nparser = ArgumentParser()\nparser.add_argument(\"string\", nargs=\"?\", default=UNSET)\nparser.add_argument(\n\"-d\",\n\"--depth\",\ntype=int,\nchoices=(3, 4, 8, 24),\ndefault=4\n)\nparser.add_argument(\"-c\", \"--clean\", action=\"store_true\")\nparser.add_argument(\"-t\", \"--test\", action=\"store_true\")\n</code></pre> <pre><code>from paperbush import Paperbush\nUNSET = object()\nparser = Paperbush(\n\"string:?=$0 --depth:int:(3, 4, 8, 24)=4 --clean --test\",\nUNSET\n)\n</code></pre> argparsePaperbush <pre><code>from argparse import ArgumentParser\nparser = ArgumentParser()\ngroup = parser.add_mutually_exclusive_group()\ngroup.add_argument(\"-m\")\ngroup.add_argument(\"-c\")\nparser.add_argument(\"-O\", action=\"count\")\nparser.add_argument(\"-q\", action=\"store_true\")\n</code></pre> <pre><code>from paperbush import Paperbush\nparser = Paperbush(\"-m:str ^ -c:str -O++ -q\")\n</code></pre> argparsePaperbush <pre><code>import sys\nfrom argparse import ArgumentParser\nparser = ArgumentParser()\nparser.add_argument(\"-i\", \"--inputs\", nargs=\"*\")\nparser.add_argument(\"-s\", \"--smart\", action=\"store_true\")\nparser.add_argument(\"-o\", \"--output\", default=sys.stdout)\n</code></pre> <pre><code>import sys\nfrom paperbush import Paperbush\nparser = Paperbush(\"--inputs:* --smart --output=$0\", sys.stdout)\n</code></pre>"}]}